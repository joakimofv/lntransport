package lntransport

import (
	"errors"
	"net/netip"
	"reflect"
	"sync"

	"github.com/btcsuite/btcd/btcec/v2"
	"github.com/decred/dcrd/dcrec/secp256k1/v4"
)

var ErrLnTransportClosed = errors.New("use of closed LnTransport")
var ErrConnClosed = errors.New("use of closed Conn")

type Config struct {
	// Private key in bytes, used to encrypt the transport.
	//
	// The empty value won't work, it needs to be a valid secp256k1 key.
	// Tip: Use github.com/btcsuite/btcd/btcec/v2 NewPrivateKey() Serialize() to get something valid for testing etc.
	Privkey [32]byte

	// Number of incoming connection attempts that can be handled in parallel by the goroutine spawned by Listen.
	// Default: 10
	MaxParallelListenHandshakes int

	// Whether to disable logging.
	// If left at false (default) then will use stdlib log to print non-critical errors from Listen goroutines,
	// such as failed incoming connection attempts.
	ListenErrNoLog bool

	// ListenErrChan, if set to non-nil, will have non-critical errors passed to it,
	// along with the address/port of the listener that encountered the error.
	// Concerns the same errors as ListenErrNoLog.
	// Can be useful for custom logging, or specific reactions to certain failed incoming connection attempts.
	//
	// Relevant error type checks:
	//   _, ok := elem.Err.(net.Error)  // ok==true means there was a net level connection problem during an incoming connection attempt.
	//   errors.As(err, &AuthError{})  // true means there was an cryptographic authentication problem during an incoming connection attempt.
	//   errors.Is(err, ErrLnTransportClosed)
	//   errors.Is(err, context.Canceled) || errors.Is(err, context.DeadlineExceeded)
	//
	// Note: You must keep this channel drained (or set to nil) or else components of LnTransport can get blocked waiting to send on it.
	//       Channel won't be closed by LnTransport when it is closed.
	ListenErrChan chan<- ErrAndAddrPort

	// ListenErrFunc works on errors like ListenErrChan, passes them to the given function, if non-nil.
	ListenErrFunc func(ea ErrAndAddrPort)

	// TODO: Whitelist, Blacklist
}

// ErrAndAddrPort used in Config.ListenErrChan, see comment there.
type ErrAndAddrPort struct {
	Err      error
	AddrPort netip.AddrPort
}

// LnTransport is an object which can listen for and/or dial up connections
// with the transport protocol specified by https://github.com/lightning/bolts/blob/master/08-transport.md
//
// Must be created with New.
// Close must be called to ensure resources are released.
//
// LnTransport is safe for concurrent use by multiple goroutines.
type LnTransport struct {
	wg          *sync.WaitGroup
	closed      chan struct{}
	closedMutex *sync.RWMutex

	cfg Config

	contexts chan contextInfo
	privkey  *btcec.PrivateKey

	// cases is only used inside contextwatcher, but keep it here for observability in tests.
	cases []reflect.SelectCase
}

// New validates the Config and uses it to create a LnTransport.
func New(cfg Config) (*LnTransport, error) {
	lt := &LnTransport{
		wg:          new(sync.WaitGroup),
		closed:      make(chan struct{}),
		closedMutex: new(sync.RWMutex),
		cfg:         cfg,
		contexts:    make(chan contextInfo),
	}
	if lt.cfg.MaxParallelListenHandshakes == 0 {
		lt.cfg.MaxParallelListenHandshakes = 10
	}

	// Prepare the privkey from the cfg.
	lt.privkey = secp256k1.PrivKeyFromBytes(cfg.Privkey[:])
	// Validate it by getting the pubkey and checking that it is "on curve".
	pubkey := lt.privkey.PubKey()
	if !pubkey.IsOnCurve() {
		return nil, errors.New("invalid Privkey (corresponding Pubkey is not on the secp256k1 curve)")
	}

	lt.wg.Add(1)
	go lt.contextWatcher()

	return lt, nil
}

// Close stops spawned goroutines, including listeners. Idempotent.
//
// Future calls to Dial or Listen will return ErrLnTransportClosed.
//
// All Conns that have been generated by LnTransport will on Send/Receive be closed and return ErrLnTransportClosed.
func (lt *LnTransport) Close() error {
	lt.closedMutex.Lock()
	select {
	case <-lt.closed:
		lt.closedMutex.Unlock()
		return nil
	default:
	}
	close(lt.closed)
	lt.closedMutex.Unlock()

	lt.wg.Wait()
	return nil
}

func (lt *LnTransport) isClosed() bool {
	select {
	case <-lt.closed:
		return true
	default:
		return false
	}
}

// Pubkey returns the public key that corresponds to the private key that LnTransport was created with.
func (lt *LnTransport) Pubkey() [33]byte {
	var b [33]byte
	copy(b[:], lt.privkey.PubKey().SerializeCompressed())
	return b
}
